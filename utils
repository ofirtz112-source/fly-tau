from datetime import datetime, date, time

def _format_datetime(value):
    if value is None:
        return ""
    if isinstance(value, datetime):
        dt = value
    else:
        try:
            dt = datetime.strptime(str(value), "%Y-%m-%d %H:%M:%S")
        except ValueError:
            return str(value)
    return dt.strftime("%d %b %Y, %H:%M")


def _format_price(value):
    if value is None or value == "":
        return "—"
    try:
        n = float(value)
        if n.is_integer():
            return f"₪{int(n):,}"
        return f"₪{n:,.2f}"
    except (ValueError, TypeError):
        return f"₪{value}"


def prepare_flights_for_view(flights):
    prepared = []
    for f in flights or []:
        f = dict(f)
        f["departure_display"] = _format_datetime(f.get("departure_time"))
        f["arrival_display"] = _format_datetime(f.get("arrival_time"))
        f["price_display"] = _format_price(f.get("min_price"))
        prepared.append(f)
    return prepared


import math
import string

def _block_sizes(total_cols: int, max_block: int) -> list[int]:
    """
    Split total_cols into balanced block sizes, each <= max_block.
    Example: total=9, max=3 -> [3,3,3]
             total=7, max=3 -> [2,3,2]
             total=4, max=3 -> [2,2]
    """
    if not total_cols or total_cols <= 0:
        return []

    k = math.ceil(total_cols / max_block)  # number of blocks needed
    base = total_cols // k
    rem = total_cols % k

    sizes = [base] * k

    # Distribute the remainder to the middle first for symmetry
    order = []
    mid = (k - 1) // 2
    order.append(mid)
    for d in range(1, k):
        left = mid - d
        right = mid + d
        if left >= 0:
            order.append(left)
        if right < k:
            order.append(right)
        if len(order) >= k:
            break

    for i in range(rem):
        sizes[order[i]] += 1

    # Safety (shouldn't exceed max_block by construction)
    if any(s > max_block for s in sizes):
        # fallback: simple greedy chunks
        sizes = [max_block] * (total_cols // max_block)
        tail = total_cols % max_block
        if tail:
            sizes.append(tail)

    return sizes


def build_seatmap_layout(class_type: str, num_rows: int, num_cols: int, aisle_px: int = 64) -> dict:
    """
    Returns layout info for rendering a class section with CSS Grid.
    """
    max_block = 2 if class_type.lower() == "business" else 3

    blocks = _block_sizes(int(num_cols), max_block)
    # positions like: ['seat','seat','aisle','seat'...]
    positions = []
    for bi, b in enumerate(blocks):
        positions += ["seat"] * b
        if bi != len(blocks) - 1:
            positions.append("aisle")

    # CSS grid template columns
    # seats: minmax(34px, 1fr), aisle: fixed px
    cols_parts = []
    for bi, b in enumerate(blocks):
        cols_parts.append(f"repeat({b}, minmax(34px, 1fr))")
        if bi != len(blocks) - 1:
            cols_parts.append(f"{aisle_px}px")
    grid_cols = " ".join(cols_parts)

    # seat letters: A, B, C...
    letters = list(string.ascii_uppercase[:int(num_cols)])

    return {
        "class_type": class_type,
        "num_rows": int(num_rows),
        "num_cols": int(num_cols),
        "blocks": blocks,
        "positions": positions,
        "grid_cols": grid_cols,
        "letters": letters,
        "aisle_px": aisle_px
    }


