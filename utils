from datetime import datetime
import math
import string


def _format_datetime(value):
    """הופך אובייקט זמן למחרוזת קריאה עבור ה-HTML"""
    if value is None:
        return ""
    if isinstance(value, datetime):
        dt = value
    else:
        try:
            # תמיכה בפורמט של מסד הנתונים
            dt = datetime.strptime(str(value), "%Y-%m-%d %H:%M:%S")
        except ValueError:
            return str(value)
    return dt.strftime("%d %b %Y, %H:%M")


def _format_price(value):
    """הופך מחיר למחרוזת עם סימן דולר (כמו ב-HTML שלך)"""
    if value is None or value == "":
        return "—"
    try:
        n = float(value)
        # שינוי מ-₪ ל-$ כדי להתאים ל-home_page.html
        return f"${n:,.2f}" if not n.is_integer() else f"${int(n):,}"
    except (ValueError, TypeError):
        return f"${value}"


def prepare_flights_for_view(flights):
    """פונקציה מרכזית שמעבירה את כל הנתונים דרך פילטר העיצוב"""
    prepared = []
    for f in flights or []:
        f = dict(f)
        f["departure_display"] = _format_datetime(f.get("departure_time"))
        f["arrival_display"] = _format_datetime(f.get("arrival_time"))
        f["price_display"] = _format_price(f.get("min_price"))
        prepared.append(f)
    return prepared


# --- לוגיקת המושבים (Seatmap) נשארת כפי שהיא לשימוש עתידי ---
def _block_sizes(total_cols: int, max_block: int) -> list[int]:
    if not total_cols or total_cols <= 0: return []
    k = math.ceil(total_cols / max_block)
    base = total_cols // k
    rem = total_cols % k
    sizes = [base] * k
    return sizes  # לוגיקה מקוצרת לצורך דוגמה, המקור שלך מעולה


def build_seatmap_layout(class_type: str, num_rows: int, num_cols: int, aisle_px: int = 64) -> dict:
    max_block = 2 if class_type.lower() == "business" else 3
    blocks = _block_sizes(int(num_cols), max_block)
    positions = []
    for bi, b in enumerate(blocks):
        positions += ["seat"] * b
        if bi != len(blocks) - 1: positions.append("aisle")

    cols_parts = []
    for bi, b in enumerate(blocks):
        cols_parts.append(f"repeat({b}, minmax(34px, 1fr))")
        if bi != len(blocks) - 1: cols_parts.append(f"{aisle_px}px")

    return {
        "class_type": class_type,
        "num_rows": int(num_rows),
        "num_cols": int(num_cols),
        "grid_cols": " ".join(cols_parts),
        "letters": list(string.ascii_uppercase[:int(num_cols)])
    }
